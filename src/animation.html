<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Animation</title>
</head>
<style>
    body {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 90vh;
        background-color: #000;
    }

    .moving-element {
        position: relative;
        width: 750px;
        height: 750px;
        border: 1px solid #0ccde2;
    }

    .moving-element__dot {
        width: 24px;
        height: 24px;
        border: 6px solid #000000;
        border-radius: 50%;
        background-color: #CD40FF;
        filter: drop-shadow(0 10px 25px #CD40FF);
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2;
    }

    .moving-element__dot:nth-of-type(2) {
        background: #04ADBF;
    }

    .moving-element__line {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%
    }

    .moving-element__line_shadow {
        filter: drop-shadow(0 10px 25px #CD40FF);
    }

    .moving-element__line svg line {
        stroke-width: 5px;
    }
</style>
<body>

<div class="moving-element">
    <div class="moving-element__dot"></div>
    <div class="moving-element__dot"></div>
    <div class="moving-element__dot"></div>
    <div class="moving-element__dot"></div>

    <div class="moving-element__line">
        <svg viewbox=" 0 0 350 350"></svg>
    </div>
    <div class="moving-element__line">
        <svg viewbox=" 0 0 350 350"></svg>
    </div>
    <div class="moving-element__line">
        <svg viewbox=" 0 0 350 350"></svg>
    </div>
    <div class="moving-element__line">
        <svg viewbox=" 0 0 350 350"></svg>
    </div>
    <div class="moving-element__line">
        <svg viewbox=" 0 0 350 350"></svg>
    </div>
    <div class="moving-element__line">
        <svg viewbox=" 0 0 350 350"></svg>
    </div>
</div>

<script>
    function random(min, max) {
        let num = Math.floor(Math.random() * (max - min + 1)) + min;
        return num;
    }

    function createLine(dot1, dot2, num) {
        let x1 = dot1.x + +dot1.dotHTML.getBoundingClientRect().width / 2,
            y1 = dot1.y + +dot1.dotHTML.getBoundingClientRect().height / 2,
            x2 = dot2.x + +dot2.dotHTML.getBoundingClientRect().width / 2,
            y2 = dot2.y + +dot2.dotHTML.getBoundingClientRect().height / 2
        let colorDot1, colorDot2, strokeColor = `url(#Gradient${num})`

        if (x1 <= x2) {
            colorDot1 = dot1.color
            colorDot2 = dot2.color
        } else {
            colorDot1 = dot2.color
            colorDot2 = dot1.color
        }

        if (x1 === x2 || y1 === y2) {
            strokeColor = '#CD40FF'
        }

        return `
        <defs><linearGradient id="Gradient${num}">
            <stop offset="0%" stop-color="${colorDot1}"/>
            <stop offset="100%" stop-color="${colorDot2}"/>
        </linearGradient></defs>
        <line class="moving-element__line_shadow" stroke="${strokeColor}" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}"/>`
    }

    class Dot {
        constructor(movingDot, x, y, velX, velY,) {
            this.dotHTML = movingDot
            this.x = x
            this.y = y
            this.velX = velX
            this.velY = velY
            this.color = getComputedStyle(this.dotHTML).backgroundColor
        }

        update(boundRect) {
            if ((this.dotHTML.getBoundingClientRect().left + this.dotHTML.getBoundingClientRect().width) >= boundRect.getBoundingClientRect().right
                || ((this.dotHTML.getBoundingClientRect().left) < boundRect.getBoundingClientRect().left)) {
                this.velX = -(this.velX);
            }

            if ((this.dotHTML.getBoundingClientRect().top + this.dotHTML.getBoundingClientRect().width) >= boundRect.getBoundingClientRect().bottom
                || ((this.dotHTML.getBoundingClientRect().top) < boundRect.getBoundingClientRect().top)) {
                this.velY = -(this.velY);
            }
            this.x += this.velX
            this.y += this.velY
            this.dotHTML.style.left = this.x + 'px';
            this.dotHTML.style.top = this.y + 'px';
        }
    }

    class Tetrahedron {
        constructor(movingElement) {
            this.dots = []
            this.boundElement = movingElement

            movingElement.querySelectorAll('.moving-element__dot').forEach(currentDot => {
                let dot = new Dot(
                    currentDot,
                    random(0, movingElement.getBoundingClientRect().width - currentDot.getBoundingClientRect().width),
                    random(0, movingElement.getBoundingClientRect().height - currentDot.getBoundingClientRect().height),
                    random(-1, 1),
                    random(-1, 1))

                this.dots.push(dot)
            })

            movingElement.querySelectorAll('.moving-element__line').forEach(line => {
                line.innerHTML = `<svg viewbox=" 0 0 ${this.boundElement.getBoundingClientRect().width} ${this.boundElement.getBoundingClientRect().height}"></svg>`
            })
        }

        updateLines() {
            let allLines = this.boundElement.querySelectorAll('.moving-element__line svg')

            allLines[0].innerHTML = createLine(this.dots[0], this.dots[1], 1)
            allLines[1].innerHTML = createLine(this.dots[0], this.dots[2], 2)
            allLines[2].innerHTML = createLine(this.dots[0], this.dots[3], 3)
            allLines[3].innerHTML = createLine(this.dots[1], this.dots[2], 4)
            allLines[4].innerHTML = createLine(this.dots[1], this.dots[3], 5)
            allLines[5].innerHTML = createLine(this.dots[2], this.dots[3], 6)
        }

        update() {
            this.updateLines()

            this.dots.forEach(dot => {
                dot.update(this.boundElement)
            })
        }
    }

    let testTetrahedron = new Tetrahedron(document.querySelector('.moving-element'))

    function loop() {
        testTetrahedron.update()
        requestAnimationFrame(loop);
    }

    loop()

</script>
</body>
</html>